{
    "subject": "Domain Repository",
    "fact": "Domain Repository interface must not use Observable / RxJS / framework abstraction",
    "citations": "Domain Layer should only describe domain contracts; Repository must not expose implementation detail.",
    "reason": "Concepts like Observable belong to Infrastructure; Domain only describes behavior and Aggregate access, and should not depend on implementation.",
    "category": "Domain Layer"
  },
  {
    "subject": "Aggregate Boundary",
    "fact": "Each Aggregate Root must have a corresponding Repository, and Repository must not cross Aggregates",
    "citations": "DDD Principle: one Aggregate Root = one Repository",
    "reason": "Maintain consistency boundaries and avoid unintended side effects across Aggregates.",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Method Naming",
    "fact": "Domain Repository must not have UI-oriented APIs like getAll, getUsers, watch*",
    "citations": "Repository interface only describes business behavior, not designed for UI or Store",
    "reason": "Prevent Domain layer from being polluted by UI / Store requirements.",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Return Types",
    "fact": "Domain Repository can only return Promise or synchronous values, Observable is forbidden",
    "citations": "DDD: Domain should remain pure, asynchronous handling is for Application/Infrastructure",
    "reason": "Keep Domain layer independent of async implementation details.",
    "category": "Domain Layer"
  },
  {
    "subject": "Value Object Usage",
    "fact": "Repository and Entity IDs must use Value Object, passing string/number directly is forbidden",
    "citations": "DDD: Value Objects encapsulate identity, enhance type safety",
    "reason": "Protect Domain type safety and unify Aggregate identity representation.",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Services",
    "fact": "Domain Services can only depend on Domain Repository interface, must not use Infrastructure / UI",
    "citations": "DDD: Domain Service is pure domain logic",
    "reason": "Prevent Domain Service from being polluted by implementation details.",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Dependency",
    "fact": "Application layer can only depend on Domain layer, must not use Infrastructure implementations directly",
    "citations": "Layered Architecture: Application orchestrates Domain, does not know Infrastructure",
    "reason": "Keep layer boundaries clear and prevent Application layer from leaking into Infrastructure.",
    "category": "Application Layer"
  },
  {
    "subject": "Facade / Store",
    "fact": "Facade / Store must not expose Repository API or Observable, only provide Signals or pure state",
    "citations": "Application Layer: provide state for Presentation only",
    "reason": "Presentation should not operate Repository directly, preventing side effects from leaking.",
    "category": "Application Layer"
  },
  {
    "subject": "Guard",
    "fact": "Guard can only perform pure condition checks, subscribe, navigation, or side effects are forbidden",
    "citations": "Application Layer: Guards are pure, signals-only",
    "reason": "Prevent Guard from becoming a control flow or data mutation point, keep it pure.",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer",
    "fact": "Infrastructure implements Domain Repository, can use Observable / AngularFire / Firestore",
    "citations": "DDD: Infrastructure adapts persistence to Domain contract",
    "reason": "Infrastructure layer can depend on frameworks, but must not pollute Domain.",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer",
    "fact": "Presentation layer must not import Domain Repository or Infrastructure, only use Facade / Store",
    "citations": "DDD + Layered Architecture: Presentation only sees Application layer",
    "reason": "Keep layer boundaries, prevent UI from leaking into business logic.",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer",
    "fact": "Shared only allows base Value Objects / enums / error / interfaces, must not depend on Application / Infrastructure / Presentation",
    "citations": "Shared layer is framework-agnostic and cross-layer stable",
    "reason": "Maintain reusability and layer independence.",
    "category": "Shared Layer"
  },
  {
    "subject": "Domain Repository Contract",
    "fact": "Domain Repository interface can only use Promise or synchronous values, must not depend on Observable / RxJS / framework",
    "citations": "DDD: Repository is a domain contract, infrastructure-specific behavior must not leak",
    "reason": "Keep Domain pure, avoid timeline / UI concept pollution",
    "category": "Domain Layer"
  },
  {
    "subject": "Aggregate Boundary",
    "fact": "Each Aggregate Root must have a separate Repository, Repository must not cross Aggregates",
    "citations": "DDD Principle: one Aggregate Root = one Repository",
    "reason": "Maintain consistency boundaries, prevent cross-Aggregate side effects",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Naming",
    "fact": "Domain Repository must not use UI-oriented APIs like getAll / getUsers / watch*",
    "citations": "Repository is about domain behavior, not UI convenience",
    "reason": "Prevent Domain from being polluted by Presentation or Store",
    "category": "Domain Layer"
  },
  {
    "subject": "Value Object Enforcement",
    "fact": "Aggregate IDs and Owner must use Value Object, string/number is forbidden",
    "citations": "DDD: Value Objects encapsulate identity",
    "reason": "Maintain type safety and Domain semantic consistency",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Service Dependency",
    "fact": "Domain Service can only depend on Domain Repository interface, must not use Infrastructure / UI",
    "citations": "DDD: Domain Service is pure domain logic",
    "reason": "Keep Domain pure, not polluted by implementation details",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Orchestration",
    "fact": "Application layer can only depend on Domain layer, using Facade / Store / Guards to orchestrate Use Case",
    "citations": "Layered Architecture: Application orchestrates Domain",
    "reason": "Keep layers clear, prevent Infrastructure or UI from leaking in",
    "category": "Application Layer"
  },
  {
    "subject": "Use Case Output",
    "fact": "Use Case must not return Observable, only use Promise or pure data structures",
    "citations": "DDD + Clean Architecture: Domain async handling stays in infrastructure",
    "reason": "Application layer is responsible for converting to Signals / Store / Presentation-usable state",
    "category": "Application Layer"
  },
  {
    "subject": "Facade / Store Rules",
    "fact": "Facade / Store must not expose Repository API or Observable, only provide Signals or pure state",
    "citations": "Application Layer provides state for Presentation only",
    "reason": "Presentation must not depend on Repository directly, preventing side effects from leaking",
    "category": "Application Layer"
  },
  {
    "subject": "Guard Purity",
    "fact": "Guard can only perform synchronous or signals-only checks, no side effects, navigation, or subscribe",
    "citations": "Application Layer: Guards are pure and signals-only",
    "reason": "Prevent Guard from becoming a control flow or data mutation point",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer Implementation",
    "fact": "Infrastructure can use Observable / AngularFire / Firestore, but must not pollute Domain",
    "citations": "DDD: Infrastructure adapts persistence to Domain contract",
    "reason": "Implementation details are encapsulated in Infrastructure layer, Domain remains pure",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer Rules",
    "fact": "Presentation must not import Domain Repository or Infrastructure, only use Application Facade / Store",
    "citations": "DDD + Clean Architecture: Presentation only sees Application",
    "reason": "Keep layer boundaries, UI must not operate Domain / Infrastructure directly",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer Rules",
    "fact": "Shared can only contain Value Objects / enums / error / interfaces, must not depend on Application / Infrastructure / Presentation",
    "citations": "Shared layer must remain framework-agnostic and cross-layer stable",
    "reason": "Maintain reusability and layer independence",
    "category": "Shared Layer"
  },
  {
    "subject": "Global Layer Enforcement",
    "fact": "No layer may import across boundaries, Infrastructure / UI APIs must not leak into Domain",
    "citations": "Layered Architecture / DDD",
    "reason": "Maintain clear boundaries, Fail-Fast principle",
    "category": "All Layers"
  },
  {
    "subject": "Fail-Fast Behavior",
    "fact": "Copilot must immediately stop implementation if Domain uses Observable, getUsers, cross-Aggregate Repository, etc.",
    "citations": "Domain pureness must be enforced",
    "reason": "Prevent improper dependencies from entering core Domain",
    "category": "All Layers"
  },
  {
    "subject": "Infrastructure Adapter Pattern",
    "fact": "Any Infrastructure providing real-time data must do so via Adapter, Domain must not expose real-time streams directly",
    "citations": "Clean Architecture / DDD: Adapter isolates Infrastructure",
    "reason": "Keep Domain and Application independent",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Application to Presentation Mapping",
    "fact": "Application must convert Domain Entity to Presentation Signals or ViewModel",
    "citations": "Clean Architecture: Application mediates between Domain and Presentation",
    "reason": "Prevent Presentation from depending directly on Domain",
    "category": "Application Layer"
  },
  {
    "subject": "Domain Layer",
    "fact": "Domain layer includes Aggregate Root, Entity, Value Object, Domain Service, Repository Interface",
    "citations": "DDD: Domain Layer is the heart of business logic",
    "reason": "Domain layer expresses business concepts, all business rules are centralized here",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer Dependency",
    "fact": "Domain layer must not depend on Application, Infrastructure, or Presentation layers",
    "citations": "Layered Architecture: Domain is independent",
    "reason": "Keep Domain pure, avoid business logic being polluted by external technology",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer",
    "fact": "Application layer includes Use Case, Facade, Store, Guard, Application Service, Mapper, Token",
    "citations": "Clean Architecture: Application orchestrates domain, provides use case API",
    "reason": "Application layer coordinates Domain behavior and provides it to Presentation layer",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Dependency",
    "fact": "Application layer can depend on Domain and Shared layers, but not on Infrastructure or Presentation layers",
    "citations": "Clean Architecture: Application depends only on domain abstractions",
    "reason": "Maintain layer boundaries, Infrastructure details can only be injected via Repository implementation",
    "category": "Application Layer"
  },
  {
    "subject": "Infrastructure Layer",
    "fact": "Infrastructure layer includes Repository implementation, third-party service adapters, data access, DTO, Converters, Collections",
    "citations": "DDD: Infrastructure adapts external systems to domain contracts",
    "reason": "Infrastructure encapsulates technical details, Domain only sees interface, not implementation",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Infrastructure Layer Dependency",
    "fact": "Infrastructure layer can depend on Domain and Shared layers, but not on Application or Presentation layers",
    "citations": "Layered Architecture: Infrastructure is below Application, above external systems",
    "reason": "Keep Domain and Application layers independent, Infrastructure is just an Adapter",
    "category": "Infrastructure Layer"
  },
  {
    "subject": "Presentation Layer",
    "fact": "Presentation layer includes Component, Page, Layout, Feature, Shared UI Service, Route, Signal / State",
    "citations": "Clean Architecture: Presentation consumes Application facades and stores",
    "reason": "Presentation is only responsible for display and user interaction, not business logic",
    "category": "Presentation Layer"
  },
  {
    "subject": "Presentation Layer Dependency",
    "fact": "Presentation layer can depend on Application and Shared layers, but not directly on Domain or Infrastructure",
    "citations": "Clean Architecture: Presentation only sees Application APIs",
    "reason": "Prevent UI layer from operating Repository or Domain directly, maintain boundaries",
    "category": "Presentation Layer"
  },
  {
    "subject": "Shared Layer",
    "fact": "Shared layer includes Value Object, Enum, Error, Interface, common libraries or types",
    "citations": "Shared layer provides cross-layer reusable constructs",
    "reason": "Maintain layer independence, provide common types and error management for all layers",
    "category": "Shared Layer"
  },
  {
    "subject": "Shared Layer Dependency",
    "fact": "Shared layer must not depend on Domain, Application, Infrastructure, or Presentation layers",
    "citations": "Shared layer must remain framework-agnostic and cross-layer stable",
    "reason": "Avoid circular dependencies, keep layers clear",
    "category": "Shared Layer"
  },
  {
    "subject": "Global Layer Dependency Rule",
    "fact": "Dependency direction must be one-way: Presentation → Application → Domain ← Infrastructure, Shared can be depended on by all layers",
    "citations": "Clean Architecture / DDD layered structure",
    "reason": "Ensure architectural stability, prevent cross-layer cycles or pollution",
    "category": "All Layers"
  },
  {
    "subject": "Fail-Fast Enforcement",
    "fact": "Any layer violating dependency rules or using APIs from the wrong layer, Copilot must immediately stop implementation and prompt for correction",
    "citations": "DDD + Clean Architecture principles",
    "reason": "Maintain project layer boundaries and architectural purity",
    "category": "All Layers"
  },
  {
    "subject": "Aggregate Invariants",
    "fact": "Each Aggregate Root must encapsulate its invariants, external code must not break state directly",
    "citations": "DDD: Aggregates enforce business invariants internally",
    "reason": "Prevent business logic from being misused or Entity state being modified directly",
    "category": "Domain Layer"
  },
  {
    "subject": "Entity Identity",
    "fact": "Each Entity must have a unique ID and the ID must be immutable",
    "citations": "DDD: Entity identity distinguishes objects, should be immutable",
    "reason": "Ensure the same Entity is unique and traceable throughout the system",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Events",
    "fact": "Domain can define events, but events only describe facts and do not perform side effects",
    "citations": "DDD: Domain events describe state changes, side effects handled by Application",
    "reason": "Keep Domain pure, side effects are handled by Application or Infrastructure",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Error Handling",
    "fact": "Domain layer errors should be wrapped using DomainError or ValidationError types",
    "citations": "DDD: Domain should control its own exception types",
    "reason": "Unify error types, avoid noise from Infrastructure or UI leaking in",
    "category": "Domain Layer"
  },
  {
    "subject": "Domain Layer No Public Setter",
    "fact": "Domain Entity properties must not provide public setters, modification must be via methods or Aggregate behavior",
    "citations": "DDD: enforce invariants via behavior, not direct mutation",
    "reason": "Prevent external code from breaking Aggregate state",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Interface Naming",
    "fact": "Repository interface naming must end with Aggregate name + Repository, e.g., UserRepository",
    "citations": "DDD naming convention",
    "reason": "Maintain readability and consistency, quickly identify each Aggregate's storage interface",
    "category": "Domain Layer"
  },
  {
    "subject": "Repository Method Signature",
    "fact": "Repository must not pass raw data structures to Domain, all input/output must use Value Object or Entity",
    "citations": "DDD: Repository is domain contract",
    "reason": "Ensure Domain is not polluted by DTO / Database structures",
    "category": "Domain Layer"
  },
  {
    "subject": "Application Layer Use Case Isolation",
    "fact": "Each Use Case must be a separate class or function, encapsulating a single business operation",
    "citations": "Clean Architecture: Use Case represents one application service",
    "reason": "Clear responsibility boundaries, avoid mixing multiple business logic",
    "category": "Application Layer"
  },
  {
    "subject": "Application Layer Side Effects",
    "fact": "Use Case or Application Service can perform side effects, but must do so via Repository / Service Adapter",
    "citations": "Clean Architecture: Application layer mediates between Domain and external system",
    "reason": "Domain layer remains pure, Infrastructure handles side effects",
    "category": "Application Layer"
  },
  {
    "subject": "Facade Read-only Exposure",
    "fact": "Facade can only expose state or Signals, must not provide methods to modify Repository directly",
    "citations": "DDD + Angular Signals: Presentation should not mutate domain directly",
    "reason": "Prevent UI layer from breaking Domain behavior",
    "category": "Application Layer"
  },
